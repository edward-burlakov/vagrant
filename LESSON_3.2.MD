1) Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

Ответ:
root@vagrant:~/test# type -a cd
cd is a shell builtin.

    Эта команда должна быть уникальна в момент исполнения для данного экземпляра оболочки BASH, 
    в которой работает пользователь.  
    Если команда "cd" будет приложением с отдельным исполняемым процессом, то гарантировано возникнет ситуация, 
    когда запущены два и более параллельных процесса выполнения команды cd. 
    При запуске данной команды ключевым параметром, который оболочка BASH передает процессу "cd" - это текущий каталог. 
    И данный параметр не изменится, пока не завершится исполнение процесса "cd" и он не умрет.


    - Если очередной  инстанс процесса "cd" будет запущен, пока не завершился предыдущий, то переданное ему 
      значение переменной текущего каталога для выполнения команды "cd" 
      с "относительными" атрибутами (ссылающимися на текущий каталог) может быть некорректным.

    - Это справедливо и для факта завершения. Вполне вероятна обработка двух и более инстансов команды "cd" 
      в работающих параллельно скриптах, запущенных в оболочке BASH. 
      Это может привести к неоднозначным результатам исполнения этих скриптов. 
      Внутри скрипта значение целевого каталога пользователя после завершения одного из инстансов cd, 
      будет передано скрипту для дальнейшего исполнения, в то время, как работа другого параллельного процесса "cd" 
      в другом скрипте еще не завершилась.

#----------------------------------------------------------------------------------------------------------------------------------------------------

2) Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l ? 
   man grep поможет в ответе на этот вопрос. 
   Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
    
Ответ :

     1. Вариант с pipe :  cat <some_file> | grep -c <some_string> 
     2. Вариант без pipe : grep -c -F <some_string>  <some_file>

          root@vagrant:~/test# cat test.txt
          string1
          string1
          string100
          string1
          string100
          string1
          string1
          root@vagrant:~/test# grep -c -F string100 test.txt
          2
     3. Еще вариант без pipe : fgrep -c  <some_string>  <some_file>    - Для обратной совместимости старых скриптов

#----------------------------------------------------------------------------------------------------------------------------------------------------

3) Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Ответ: systemd(1)

    root@vagrant:~/test# pstree -p -s  | grep \(1\)
    systemd(1)-+-ModemManager(680)-+-{ModemManager}(692)

#----------------------------------------------------------------------------------------------------------------------------------------------------

4) Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
  
Ответ:

С хостом vagrant установлены две терминальные сессии:

    root@vagrant:~/test# ls -la /dev/pts
    total 0
    drwxr-xr-x  2 root    root      0 Jun 23 06:33 .
    drwxr-xr-x 19 root    root   3980 Jun 23 06:33 ..
    crw--w----  1 vagrant tty  136, 0 Jun 23 10:02 0
    crw--w----  1 vagrant tty  136, 1 Jun 23 10:02 1
    c---------  1 root    root   5, 2 Jun 23 09:59 ptmx

Мы находимся в сессии терминала, связанной с /dev/pts/0 .

    vagrant@vagrant:~$ lsof -p $$ | grep CHR
    bash    1583 vagrant    0u   CHR  136,0      0t0       4 /dev/pts/0
    bash    1583 vagrant    1u   CHR  136,0      0t0       4 /dev/pts/0
    bash    1583 vagrant    2u   CHR  136,0      0t0       4 /dev/pts/0
    bash    1583 vagrant  255u   CHR  136,0      0t0       4 /dev/pts/0

Перенаправляем вывод ошибок в сессию терминала, связанную с /dev/pts/1

    vagrant@vagrant:~/# ls -la  2>/dev/pts/1    

#----------------------------------------------------------------------------------------------------------------------------------------------------

5) Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
    
Ответ:

    root@vagrant:~/test# touch test1 test2   # Создаем два файла
    root@vagrant:~/test# echo 12345 > test1  # Заполняем файл test1  
    root@vagrant:~/test# cat test1 > test2   # Выводим stdout в файл test1
    root@vagrant:~/test# cat test2           # Анализируем содержимое файла test2 
    12345

#----------------------------------------------------------------------------------------------------------------------------------------------------

6) Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Ответ:

Нет графического интерфейса LINUX для проверки. Вероятно что да.

#----------------------------------------------------------------------------------------------------------------------------------------------------

7) Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Ответ:
   
Выполняем

    root@vagrant:/home/vagrant# bash 5>&1

При выполнении команды bash 5>&1 будет запущен новый процесс оболочки bash 
и будет создан символьный файловый дескриптор c индексом 5 в  /proc/$$/fd/ .
Любые данные, направляемые в дескриптор 5, будут перенаправлены на устройство  с дескриптором (1).  

    root@vagrant:/home/vagrant# ls -la /proc/1770/fd
    total 0
    dr-x------ 2 root root  0 Jun 23 10:31 .
    dr-xr-xr-x 9 root root  0 Jun 23 10:31 ..
    lrwx------ 1 root root 64 Jun 23 10:31 0 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 1 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 2 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 255 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 5 -> /dev/pts/1

Сначала исполняется команда echo, которая является shell-командой в оболочке BASH.

    root@vagrant:/home/vagrant# type -a echo
    echo is a shell builtin
    echo is /usr/bin/echo
    echo is /bin/echo

Запускаем

    root@vagrant:/home/vagrant# echo netology > /proc/$$/fd/5
    netology

Shell-командa echo направляет поток stdout на объект с дескриптором 1, 
если явно не указано иное, куда выдавать результат ее выполнения.
Но мы явно создали дескриптор с индексом 5 и связали его с направление потока вывода stdout.
Поэтому файловый дескриптор 5 в свою очередь передаст поток данных на процесс stdout с дескриптором 1, а он  
выведет его на терминал. 

#----------------------------------------------------------------------------------------------------------------------------------------------------

8) Получится ли в качестве входного потока для pipe использовать только stderr команды, 
   не потеряв при этом отображение stdout на pty? 
   Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. 
   Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, 
   который вы научились создавать в предыдущем вопросе.

Ответ:
  
   root@vagrant:~# cp test5 test6 7>&2 2>&1 1<&7  | grep such -n
   1:cp: cannot stat 'test5': No such file or directory

Описание:

   7<&2 Создаем новый дескриптор с индексом 7 и перенаправляем его на поток данных с индексом (2) - stderr
   2<&1 Перенаправляем потока вывода ошибок stderr с индексом (2) на поток  вывода stdout с индексом (1)
   1<&7 Перенаправляем вывод потока stdout c индексом (1) в новый дескриптор с  индексом (7).

#----------------------------------------------------------------------------------------------------------------------------------------------------

9) Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Ответ: man 5 proc  
    
Файл /proc/$$/environ  cодержит в себе список значений переменных окружения текущего процесса оболочки BASH. 
Записи разделены нулевыми байтами ('\0'), и может быть нулевой байт в конце. 

Вариант 2: 
    
    root@vagrant:~# xargs -0 -L1 -a /proc/self/environ   # Вывод содержимого файла  на теримнал как набор строк команд.
   
Вариант 3: 
    
    root@vagrant:~# printenv           # Команда без указания аргументов выводит все имеющиеся переменные окружения.
    
Вариант 4: 
 
    root@vagrant:~# env      # Устанавливает значение для указанной переменной. Без аргументов выводит все переменные.  


#----------------------------------------------------------------------------------------------------------------------------------------------------

10) Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

Ответ:

Manual page proc(5) line 226/3596
    /proc/<PID>/cmdline  - Это доступный только для чтения файл содержит полную командную строку для процесса, 
                       если этот процесс не является зомби. 
                       В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. 
                       Аргументы командной строки отображаются в этом файле как набор строк, разделенных нулевыми байтами.
                      ('\0') с еще одним нулевым байтом после последней строки.

Manual page proc(5) line 279/3596
    /proc/<PID>/exe   - В Linux 2.2 и более поздних версиях этот файл является символическую ссылкой, 
    содержащей фактический путь к исполняемой команде.

#----------------------------------------------------------------------------------------------------------------------------------------------------

11) Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

Ответ:

/proc/cpuinfo - Это набор элементов, зависящих от ЦП и системной архитектуры, для каждой поддерживаемой архитектуры
другой список. Две общие записи: процессор, который указывает номер процессора и bogomips- оценку производительности;
Это системные константы, вычисляемые при инициализации ядра. Машины SMP имеют информацию для каждого процессора.
Команда lscpu  получает информацию из этого файла.

    root@vagrant:~# lscpu | grep sse
    flags    : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall 
    nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni ssse3 cx16 pcid sse4_1 sse
    4_2 hypervisor lahf_lm pti fsgsbase md_clear flush_l1d arch_capabilities

Ответ: sse - старшая версия набора инструкций.

#----------------------------------------------------------------------------------------------------------------------------------------------------

12) При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. 
    Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. 
    Однако: 
    
      vagrant@netology1:~$ ssh localhost 'tty'
      not a tty

    Почитайте, почему так происходит, и как изменить поведение.

Ответ:

    SSH c помощью вышеуказанной конструкции может выполнить команду на удалённом сервере и тут же закрыть соединение. 

    WIKI: Команда tty обычно используется для проверки того, является ли выходной носитель терминалом. 
    Команда tty печатает имя файла терминала, подключенного к стандартному потоку STDIN. 
    Если файл не обнаружен (в случае, если tty запускается как часть сценария или команда tty передается в конвейере), 
    то в stdout выводится «not a tty», и команда завершается со статусом выхода 1.

    Для запуска ssh можно добавить ключ -t, и команда ssh выполнится c принудительным созданием псевдотерминала на удаленной стороне.

    vagrant@vagrant:~$ssh -t localhost 'tty'
    vagrant@localhost's password:
    /dev/pts/2
    Connection to localhost closed.
    vagrant@vagrant:~$ 

#----------------------------------------------------------------------------------------------------------------------------------------------------

13) Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. 
    Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, 
    который вы запустили по ошибке в обычной SSH-сессии.

Ответ: 
     В первом терминале:

     root@vagrant:/home/vagrant# tty:
     /dev/pts/0
     root@vagrant:/home/vagrant# top    - Запускаем программу top
    
     Ctrl-Z -  Приостанавливаем запущенную программу .
 
     root@vagrant:/home/vagrant# jobs    -  Проверяем, что процесс top стоит на паузе
     [1]+  Stopped                 top

     Переходим в соседний терминал:
 
     vagrant@vagrant:~$ tty
     /dev/pts/1
     vagrant@vagrant:~$ pstree -p | grep top  - Определяем PID процесса top  
     vagrant@vagrant:~$ reptyr [PID]  , выполняем команду reptyr, где PID - номер процесса  программы top
     Итог : Приложение  отображается на терминале /dev/pts/1 
#----------------------------------------------------------------------------------------------------------------------------------------------------

14) sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, 
    так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. 
    Для решения данной проблемы можно использовать конструкцию 
    echo string | sudo tee /root/new_file
    Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.

Ответ:

    Команда tee делает вывод одновременно  в 
    1) В файл, указанный в качестве параметра, предварительно очищая его .
    2) В stdout  -  окно терминала. 
    В данном примере команда получает вывод из stdin, перенаправленный через конвейер от stdout команды echo.
    Так как команда tee запущена c  правами суперпользователя, соответственно имеет права на запись в файл.

    root@vagrant:/home/vagrant# echo "Привет!"  | sudo tee /root/new_file
    Привет!
    root@vagrant:/home/vagrant# cat /root/new_file
    Привет!
