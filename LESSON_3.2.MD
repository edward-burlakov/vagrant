1) Какого типа команда cd? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

Ответ:
root@vagrant:~/test# type -a cd
cd is a shell builtin.

    Эта команда должна быть уникальна в момент исполнения для данного экземпляра оболочки BASH, 
    в которой работает пользователь.  
    Если команда "cd" будет приложением с отдельным исполняемым процессом, то гарантировано возникнет ситуация, 
    когда запущены два и более параллельных процесса выполнения команды cd. 
    При запуске данной команды ключевым параметром, который оболочка BASH передает процессу "cd" - это текущий каталог. 
    И данный параметр не изменится, пока не завершится исполнение процесса "cd" и он не умрет.


    - Если очередной  инстанс процесса "cd" будет запущен, пока не завершился предыдущий, то переданное ему 
      значение переменной текущего каталога для выполнения команды "cd" 
      с "относительными" атрибутами (ссылающимися на текущий каталог) может быть некорректным.

    - Это справедливо и для факта завершения. Вполне вероятна обработка двух и более инстансов команды "cd" 
      в работающих параллельно скриптах, запущенных в оболочке BASH. 
      Это может привести к неоднозначным результатам исполнения этих скриптов. 
      Внутри скрипта значение целевого каталога пользователя после завершения одного из инстансов cd, 
      будет передано скрипту для дальнейшего исполнения, в то время, как работа другого параллельного процесса "cd" 
      в другом скрипте еще не завершилась.

#----------------------------------------------------------------------------------------------------------------------------------------------------

2) Какая альтернатива без pipe команде grep <some_string> <some_file> | wc -l ? 
   man grep поможет в ответе на этот вопрос. 
   Ознакомьтесь с документом о других подобных некорректных вариантах использования pipe.
    
Ответ :

     1. Вариант с pipe :  cat <some_file> | grep -c <some_string> 
     2. Вариант без pipe : grep -c -F <some_string>  <some_file>

          root@vagrant:~/test# cat test.txt
          string1
          string1
          string100
          string1
          string100
          string1
          string1
          root@vagrant:~/test# grep -c -F string100 test.txt
          2
     3. Еще вариант без pipe : fgrep -c  <some_string>  <some_file>    - Для обратной совместимости старых скриптов

#----------------------------------------------------------------------------------------------------------------------------------------------------

3) Какой процесс с PID 1 является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

Ответ: systemd(1)

    root@vagrant:~/test# pstree -p -s  | grep \(1\)
    systemd(1)-+-ModemManager(680)-+-{ModemManager}(692)

#----------------------------------------------------------------------------------------------------------------------------------------------------

4) Как будет выглядеть команда, которая перенаправит вывод stderr ls на другую сессию терминала?
  
Ответ:

С хостом vagrant установлены две терминальные сессии:

    root@vagrant:~/test# ls -la /dev/pts
    total 0
    drwxr-xr-x  2 root    root      0 Jun 23 06:33 .
    drwxr-xr-x 19 root    root   3980 Jun 23 06:33 ..
    crw--w----  1 vagrant tty  136, 0 Jun 23 10:02 0
    crw--w----  1 vagrant tty  136, 1 Jun 23 10:02 1
    c---------  1 root    root   5, 2 Jun 23 09:59 ptmx

Мы находимся в сессии терминала, связанной с /dev/pts/0 .

    vagrant@vagrant:~$ lsof -p $$ | grep CHR
    bash    1583 vagrant    0u   CHR  136,0      0t0       4 /dev/pts/0
    bash    1583 vagrant    1u   CHR  136,0      0t0       4 /dev/pts/0
    bash    1583 vagrant    2u   CHR  136,0      0t0       4 /dev/pts/0
    bash    1583 vagrant  255u   CHR  136,0      0t0       4 /dev/pts/0

Перенаправляем вывод ошибок в сессию терминала, связанную с /dev/pts/1

    vagrant@vagrant:~/# ls -la  2>/dev/pts/1    

#----------------------------------------------------------------------------------------------------------------------------------------------------

5) Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.
    
Ответ:

    root@vagrant:~/test# touch test1 test2   # Создаем два файла
    root@vagrant:~/test# echo 12345 > test1  # Заполняем файл test1  
    root@vagrant:~/test# cat test1 > test2   # Выводим stdout в файл test1
    root@vagrant:~/test# cat test2           # Анализируем содержимое файла test2 
    12345

#----------------------------------------------------------------------------------------------------------------------------------------------------

6) Получится ли вывести находясь в графическом режиме данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Ответ:

#----------------------------------------------------------------------------------------------------------------------------------------------------

7) Выполните команду bash 5>&1. К чему она приведет? Что будет, если вы выполните echo netology > /proc/$$/fd/5? Почему так происходит?

Ответ:

При выполнении команды bash 5>&1  будет запущен новый процесс оболочки bash 
и будет создан символьный файловый дескриптор c индексом 5 в  /proc/$$/fd/
Любые данные, направляемые в дескриптор 5, будут перенаправлены в поток stdout (индекс 1)  

    root@vagrant:/home/vagrant# ls -la /proc/1770/fd
    total 0
    dr-x------ 2 root root  0 Jun 23 10:31 .
    dr-xr-xr-x 9 root root  0 Jun 23 10:31 ..
    lrwx------ 1 root root 64 Jun 23 10:31 0 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 1 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 2 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 255 -> /dev/pts/1
    lrwx------ 1 root root 64 Jun 23 10:31 5 -> /dev/pts/1

 Сначала исполняется команда echo является встроенная как shell-команда в оболочке BASH.

        root@vagrant:/home/vagrant# type -a echo
        echo is a shell builtin
        echo is /usr/bin/echo
        echo is /bin/echo

 BASH при выполнении встроенной команды берет дескриптор 1, если явно не указано куда выдавать поток stdout.
 Поcкольку мы явно задали направление потока вывода stdout, указав дескриптор с индексом 5.
 Файловый дескриптор 5 в свою очередь передаст поток данных на процесс дескриптора 1, а он  
 просто выведет его на терминал . 
    root@vagrant:/home/vagrant# echo netology > /proc/$$/fd/5
    netology


#----------------------------------------------------------------------------------------------------------------------------------------------------

8) Получится ли в качестве входного потока для pipe использовать только stderr команды, 
   не потеряв при этом отображение stdout на pty? 
   Напоминаем: по умолчанию через pipe передается только stdout команды слева от | на stdin команды справа. Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, 
   который вы научились создавать в предыдущем вопросе.

Ответ:

#----------------------------------------------------------------------------------------------------------------------------------------------------

9) Что выведет команда cat /proc/$$/environ? Как еще можно получить аналогичный по содержанию вывод?

Ответ: man 5 proc  
    
    Файл /proc/$$/environ  cодержит в себе список занчений переменных окружения текущего процесса оболочки BASH. 
    Записи разделены нулевыми байтами ('\0'), и может быть нулевой байт в конце. 

    Вариант 2: 
    
    root@vagrant:~# xargs -0 -L1 -a /proc/self/environ
   
    Вариант 3: 
    
    root@vagrant:~# printenv - Команда без указания аргументов выводит все имеющиеся переменные окружения
    
    Вариант 4: 
 
    root@vagrant:~# env      - Устанавливает значение для указанной переменной. Без аргументов выводит все переменные.  


#----------------------------------------------------------------------------------------------------------------------------------------------------

10) Используя man, опишите что доступно по адресам /proc/<PID>/cmdline, /proc/<PID>/exe.

Ответ:
Manual page proc(5) line 226/3596
/proc/<PID>/cmdline  - Это доступный только для чтения файл содержит полную командную строку для процесса, 
                       если этот процесс не является зомби. 
                       В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. 
                       Аргументы командной строки отображаются в этом файле как набор строк, разделенных нулевыми байтами.
                      ('\0') с еще одним нулевым байтом после последней строки.

Manual page proc(5) line 279/3596
/proc/<PID>/exe   - В Linux 2.2 и более поздних версиях этот файл является символическую ссылкой, 
содержащей фактический путь к исполняемой команде.

#----------------------------------------------------------------------------------------------------------------------------------------------------

11) Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью /proc/cpuinfo.

Ответ:

Это набор элементов, зависящих от ЦП и системной архитектуры, для каждой поддерживаемой архитектуры
другой список. Две общие записи: процессор, который указывает номер процессора и bogomips- оценку производительности;
Это системные константы, вычисляемые при инициализации ядра. Машины SMP имеют информацию для каждого процессора.
Команда lscpu  получает информацию из этого файла.

Ответ: sse 

root@vagrant:~# cat /proc/cpuinfo | grep sse
flags    : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall 
nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni ssse3 cx16 pcid sse4_1 ss
4_2 hypervisor lahf_lm pti fsgsbase md_clear flush_l1d arch_capabilities
flags    : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush mmx fxsr sse sse2 ht syscall 
nx rdtscp lm constant_tsc rep_good nopl xtopology nonstop_tsc cpuid tsc_known_freq pni ssse3 cx16 pcid sse4_1 ss
4_2 hypervisor lahf_lm pti fsgsbase md_clear flush_l1d arch_capabilities

#----------------------------------------------------------------------------------------------------------------------------------------------------

12) При открытии нового окна терминала и vagrant ssh создается новая сессия и выделяется pty. 
    Это можно подтвердить командой tty, которая упоминалась в лекции 3.2. Однако:
    vagrant@netology1:~$ ssh localhost 'tty'
    not a tty
   Почитайте, почему так происходит, и как изменить поведение.

Ответ:
SSH c помощью вышеуказанной конструкции может выполнить команду на удалённом сервере и тут же закрыть соединение. 

WIKI: Команда tty обычно используется для проверки того, является ли выходной носитель терминалом. 
Команда печатает имя файла терминала, подключенного к стандартному вводу. 
Если файл не обнаружен (в случае, если он запускается как часть сценария или команда передается в конвейере), 
то в stdout выводится «not a tty», и команда завершается со статусом выхода 1.

Для запуска ssh можно добавить ключ -t, и команда выполнится c принудительным созданием псевдотерминала на удаленной стороне.

    vagrant@vagrant:~$ssh -t localhost 'tty'
    vagrant@localhost's password:
    /dev/pts/2
    Connection to localhost closed.
    vagrant@vagrant:~$ 

#----------------------------------------------------------------------------------------------------------------------------------------------------

13) Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. 
    Попробуйте сделать это, воспользовавшись reptyr. Например, так можно перенести в screen процесс, 
    который вы запустили по ошибке в обычной SSH-сессии.

Ответ:


#----------------------------------------------------------------------------------------------------------------------------------------------------

14) sudo echo string > /root/new_file не даст выполнить перенаправление под обычным пользователем, 
    так как перенаправлением занимается процесс shell'а, который запущен без sudo под вашим пользователем. 
    Для решения данной проблемы можно использовать конструкцию 
    echo string | sudo tee /root/new_file. 
    Узнайте что делает команда tee и почему в отличие от sudo echo команда с sudo tee будет работать.
Ответ:
Команда tee делает вывод одновременно и в файл, указанный в качестве параметра, и в stdout, 
в данном примере команда получает вывод из stdin, перенаправленный через pipe от stdout команды echo
и так как команда запущена от sudo, соответственно имеет права на запись в файл