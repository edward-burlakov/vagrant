## Домашнее задание к занятию "6.6. Troubleshooting"

---
### Задача 1
Перед выполнением задания ознакомьтесь с документацией по администрированию MongoDB.
Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её нужно прервать.
Вы как инженер поддержки решили произвести данную операцию:

Напишите список операций, которые вы будете производить для остановки запроса пользователя
предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

---
### Ответ:
 Документация

[https://www.mongodb.com/docs/manual/administration/] 

1) Для решения  проблемы  необходимо включить профайлер на текущем экземпляре БД   следующей командой

       db.setProfilingLevel(1, { slowms: 180000, sampleRate: 0.42 })
       где 
          1        - уровень профилирования. Профайлер собирает данные для операций, которые занимают больше времени, чем значение slowms .
          180000   - slowms - Порог срабатывания для попадания в лог. Время операции больше 3 минут. Измеряется в  ms. 
          0.42     - sampleRate - частота дискретизации ( доля медленных операция,которые должны попасть в лог ( диапазон от 0 до 1).
 
2) Также можно использовать команду  db.currentOp(),  

- При отсутствии кластера необходимо запустить  команду на ноде с запущенным демоном mongod

                 db.currentOp(
                     {
                         "active" : true,
                         "secs_running"  : { "$gte" : 180 },     //  где db1 - имя БД ; 180 - время в секундах)
                         "ns" : /^db1\./
                     }
                 )      
                 

- Если мы имеем кластерное решение с шардами, то можно использовать двухэтапную агрегацию. 
Чтобы получить результат, относящийся только к запросам клиента, запущенным на конкретном экземпляре mongos
команду агрегации необходимо запускать  именно на данной ноде, где клиент запустил запрос.
        
        
                use admin
                db.aggregate ( [
                   // Stage 1:
                   {  
                       $currentOp : {  
                           "allUsers" : true, 
                           "localOps" : true 
                       } 
                   },
                   // Stage 2:
                   { 
                       $match : {
                          "active" : true,
                          "secs_running"  : { "$gte" : 180 },    //  где db1 - имя БД ; 180 - время в секундах) 
                          "ns" : /^db1\./
                      } 
                   }
               ] )


3) После нахождения тормозящей CRUD-операции,  можно отменить её выполнение командой 
   и сообщить о ней разработчику для исправления ситуации:

         db.killOp(opid)     //  где  opid -  ID операции. 

4) Найти все остальные медленные запросы  можно также

         - с помощью вышеуказанного профайлера;
         - с помощью explain(‘executionStats’) построить план запроса;

5) Перманентный вариант решения проблемы поставить БД на мониторинг, включив монитор FreeMonitoring, 
   где  можно просмотреть последние 24 часа активности в среде с диаграммами.
   Сама команда вернет URL-адрес, по которому  можете просмотреть показатели.

        а) Либо через интерфейс командой 
            db.enableFreeMonitoring()  
        б) Либо с помощью командной строки  
            -enableFreeMonitoring 
        в) Либо с помощью  добавления опции "cloud.monitoring.free.state:  on" в файл конфигурации /etc/mongod.conf и
           далее перезапуском экземпляра MongoDB 
             #  service mongodnetbrain start
 
 
---
### Задача 2
Перед выполнением задания познакомьтесь с документацией по Redis latency troobleshooting.
Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная 
и увеличивается пропорционально количеству реплик сервиса.

При масштабировании сервиса до N реплик вы увидели, что:

Сначала рост отношения записанных значений к истекшим
Redis блокирует операции записи
Как вы думаете, в чем может быть проблема?

---
### Ответ:

[https://redis.io/docs/reference/optimization/latency/]


---
### Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы, пользователи начали жаловаться на ошибки вида:
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?
---
### Ответ:
Налицо 5-й вариант проблем - нарушение обмена с сервером MySQL.


[https://stackoverflow.com/questions/10563619/error-code-2013-lost-connection-to-mysql-server-during-query]

---
### Задача 4
Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с большим объемом данных лучше, чем MySQL.
После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:
postmaster invoked oom-killer

Как вы думаете, что происходит?
Как бы вы решили данную проблему?

---
### Ответ:

grep "Out of memory" /var/log/messages 

Если вы получите уведомление о том, что произошло событие «недостаточно памяти», процесс OOM-killer уже выполнил свою работу, 
и вы увидите, что память освобождена.
Итак, чтобы выяснить, что произошло, нам придется просмотреть журналы
less /var/log/kern.log|grep -v 'UFW BLOCK' 
dmesg --ctime --color=always | grep -v 'UFW BLOCK'), чтобы узнать, что произошло.


Сначала выясним идентификатор (PID) процесса postmaster:

         pgrep -f postmaster
         3234.

Затем настраиваем  OOM Killer так, чтобы он  и не думал убить процесс с PID 3234 — записываем в файл oom_adj 
в соответствующем каталоге (/proc/PID/oom_adj) магическое число -17 (OOM score):
     
        echo -17 > /proc/3234/oom_adj 

Проверим заданные настройки:

        cat  /proc/3234/oom_adj 
        -17 


Одна вещь, которая делает синтаксический анализ более неудобным, чем это необходимо, заключается в том, что мы делаем
не иметь ни одной и легко анализируемой строки о контексте oom. Этот
патч реорганизует отчет oom в
1) кто вызывал oom и каков был запрос на выделение
	[ 131.751307] вызвана паника oom-killer: gfp_mask=0x6280ca(GFP_HIGHUSER_MOVABLE|__GFP_ZERO), order=0, oom_score_adj=0

2) Трассировка стека OOM
	[ 131.752399] ЦП: 16 PID: 8581 Связь: паника Не испорчено 4.18.0-rc5+ #48
	[131.753154] Название оборудования: Inspur SA5212M4/YZMB-00370-107, BIOS 4.1.10 14.11.2016
	[ 131.753806] Отслеживание вызовов:
	[131.754473] дамп_стека+0x5a/0x73
	[131.755129] dump_header+0x53/0x2dc
	[131.755775] oom_kill_process+0x228/0x420
	[ 131.756430] ? oom_badness+0x2a/0x130
	[ 131.757063] out_of_memory+0x11a/0x4a0
	[ 131.757710] __alloc_pages_slowpath+0x7cc/0xa1e
	[ 131.758392] ? apic_timer_interrupt+0xa/0x20
	[131.759040] __alloc_pages_nodemask+0x277/0x290
	[131.759710] alloc_pages_vma+0x73/0x180
	[131.760388] do_anonymous_page+0xed/0x5a0
	[ 131.761067] __handle_mm_fault+0xbb3/0xe70
	[131.761749] handle_mm_fault+0xfa/0x210
	[131.762457] __do_page_fault+0x233/0x4c0
	[131.763136] do_page_fault+0x32/0x140
	[ 131.763832] ? page_fault+0x8/0x30
	[131.764523] page_fault+0x1e/0x30

3) контекст oom (сдерживается и выбранная жертва).
	[ 131.771164] oom-kill:constraint=CONSTRAINT_NONE,nodemask=(null),cpuset=/,mems_allowed=0-1,task=panic,pid=8608,uid=0





[https://support.hypernode.com/en/troubleshooting/performance/how-to-debug-out-of-memory-oom-events]

[https://haydenjames.io/how-to-diagnose-oom-errors-on-linux-systems/]

[https://postgrespro.ru/list/thread-id/2426258]

      typical reason for oom-kill are too high values for work_mem.

[https://postgrespro.ru/docs/postgresql/9.6/runtime-config-resource]
  
work_mem (integer)
Задаёт объём памяти, который будет использоваться для внутренних операций сортировки 
и хеш-таблиц, прежде чем будут задействованы временные файлы на диске. 
Значение по умолчанию — четыре мегабайта (4MB). 
Заметьте, что в сложных запросах одновременно могут выполняться несколько операций 
сортировки или хеширования, и при этом указанный объём памяти может использоваться 
в каждой операции, прежде чем данные начнут вытесняться во временные файлы.
Кроме того, такие операции могут выполняться одновременно в разных сеансах. 
Таким образом, общий объём памяти может многократно превосходить значение work_mem;
это следует учитывать, выбирая подходящее значение.
Операции сортировки используются для ORDER BY, DISTINCT и соединений слиянием. 
Хеш-таблицы используются при соединениях и агрегировании по хешу,
а также обработке подзапросов IN с применением хеша.